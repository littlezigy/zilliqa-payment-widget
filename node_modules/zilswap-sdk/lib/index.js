"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
require("isomorphic-fetch");
var zilliqa_1 = require("@zilliqa-js/zilliqa");
var crypto_1 = require("@zilliqa-js/crypto");
var subscriptions_1 = require("@zilliqa-js/subscriptions");
var util_1 = require("@zilliqa-js/util");
var bignumber_js_1 = require("bignumber.js");
var async_mutex_1 = require("async-mutex");
var constants_1 = require("./constants");
var utils_1 = require("./utils");
bignumber_js_1.BigNumber.config({ EXPONENTIAL_AT: 1e9 }); // never!
var Zilswap = /** @class */ (function () {
    /**
     * Creates the Zilswap SDK object. {@linkcode initalize} needs to be called after
     * the object is created to begin watching the blockchain's state.
     *
     * @param network the Network to use, either `TestNet` or `MainNet`.
     * @param walletProviderOrKey a Provider with Wallet or private key string to be used for signing txns.
     * @param options a set of Options that will be used for all txns.
     */
    function Zilswap(network, walletProviderOrKey, options) {
        this.network = network;
        /* Txn observers */
        this.subscription = null;
        this.observer = null;
        this.observedTxs = [];
        /* Deadline tracking */
        this.deadlineBuffer = 10;
        this.currentBlock = -1;
        /* Transaction attributes */
        this._txParams = {
            version: -1,
            gasPrice: new util_1.BN(0),
            gasLimit: util_1.Long.fromNumber(30000),
        };
        if (typeof walletProviderOrKey === 'string') {
            this.zilliqa = new zilliqa_1.Zilliqa(constants_1.APIS[network]);
            this.zilliqa.wallet.addByPrivateKey(walletProviderOrKey);
        }
        else if (walletProviderOrKey) {
            this.zilliqa = new zilliqa_1.Zilliqa(constants_1.APIS[network], walletProviderOrKey.provider);
            this.walletProvider = walletProviderOrKey;
        }
        else {
            this.zilliqa = new zilliqa_1.Zilliqa(constants_1.APIS[network]);
        }
        this.contractAddress = constants_1.CONTRACTS[network];
        this.contract = (this.walletProvider || this.zilliqa).contracts.at(this.contractAddress);
        this.contractHash = crypto_1.fromBech32Address(this.contractAddress).toLowerCase();
        this.tokens = {};
        this._txParams.version = constants_1.CHAIN_VERSIONS[network];
        if (options) {
            if (options.deadlineBuffer && options.deadlineBuffer > 0)
                this.deadlineBuffer = options.deadlineBuffer;
            if (options.gasPrice && options.gasPrice > 0)
                this._txParams.gasPrice = utils_1.toPositiveQa(options.gasPrice, util_1.units.Units.Li);
            if (options.gasLimit && options.gasLimit > 0)
                this._txParams.gasLimit = util_1.Long.fromNumber(options.gasLimit);
        }
        this.observerMutex = new async_mutex_1.Mutex();
    }
    /**
     * Intializes the SDK, fetching a cache of the Zilswap contract state and
     * subscribing to subsequent state changes. You may optionally pass an array
     * of ObservedTx's to subscribe to status changes on any of those txs.
     *
     * @param subscription is the callback function to call when a tx state changes.
     * @param observedTx is the array of txs to observe.
     */
    Zilswap.prototype.initialize = function (subscription, observeTxs) {
        if (observeTxs === void 0) { observeTxs = []; }
        return __awaiter(this, void 0, void 0, function () {
            var minGasPrice;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.observedTxs = observeTxs;
                        if (subscription)
                            this.observer = subscription;
                        if (!this._txParams.gasPrice.isZero()) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.zilliqa.blockchain.getMinimumGasPrice()];
                    case 1:
                        minGasPrice = _a.sent();
                        if (!minGasPrice.result)
                            throw new Error('Failed to get min gas price.');
                        this._txParams.gasPrice = new util_1.BN(minGasPrice.result);
                        _a.label = 2;
                    case 2:
                        this.subscribeToAppChanges();
                        return [4 /*yield*/, this.loadTokenList()];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, this.updateBlockHeight()];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, this.updateAppState()];
                    case 5:
                        _a.sent();
                        return [4 /*yield*/, this.updateBalanceAndNonce()];
                    case 6:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Stops watching the Zilswap contract state.
     */
    Zilswap.prototype.teardown = function () {
        return __awaiter(this, void 0, void 0, function () {
            var stopped;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.subscription) {
                            this.subscription.stop();
                        }
                        stopped = new Promise(function (resolve) {
                            var checkSubscription = function () {
                                if (_this.subscription) {
                                    setTimeout(checkSubscription, 100);
                                }
                                else {
                                    resolve();
                                }
                            };
                            checkSubscription();
                        });
                        return [4 /*yield*/, stopped];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets the latest Zilswap app state.
     */
    Zilswap.prototype.getAppState = function () {
        if (!this.appState) {
            throw new Error('App state not loaded, call #initialize first.');
        }
        return this.appState;
    };
    /**
     * Gets the pool details for the given `tokenID`.
     *
     * @param tokenID is the token ID for the pool, which can be given by either it's symbol (defined in constants.ts),
     * hash (0x...) or bech32 address (zil...).
     * @returns {Pool} if pool exists, or `null` otherwise.
     */
    Zilswap.prototype.getPool = function (tokenID) {
        if (!this.appState) {
            throw new Error('App state not loaded, call #initialize first.');
        }
        return this.appState.pools[this.getTokenAddresses(tokenID).hash] || null;
    };
    /**
     * Gets the currently observed transactions.
     */
    Zilswap.prototype.getObservedTxs = function () {
        return __awaiter(this, void 0, void 0, function () {
            var release;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.observerMutex.acquire()];
                    case 1:
                        release = _a.sent();
                        try {
                            return [2 /*return*/, __spreadArrays(this.observedTxs)];
                        }
                        finally {
                            release();
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Converts an amount to it's unitless representation (integer, no decimals) from it's
     * human representation (with decimals based on token contract, or 12 decimals for ZIL).
     * @param tokenID is the token ID related to the conversion amount, which can be given by either it's symbol (defined in constants.ts),
     * hash (0x...) or bech32 address (zil...). The hash for ZIL is represented by the ZIL_HASH constant.
     * @param amountHuman is the amount as a human string (e.g. 4.2 for 4.2 ZILs) to be converted.
     */
    Zilswap.prototype.toUnitless = function (tokenID, amountHuman) {
        var token = this.getTokenDetails(tokenID);
        var amountUnitless = new bignumber_js_1.BigNumber(amountHuman).shiftedBy(token.decimals);
        if (!amountUnitless.integerValue().isEqualTo(amountUnitless)) {
            throw new Error("Amount " + amountHuman + " for " + token.symbol + " has too many decimals, max is " + token.decimals + ".");
        }
        return amountUnitless.toString();
    };
    /**
     * Converts an amount to it's human representation (with decimals based on token contract, or 12 decimals for ZIL)
     * from it's unitless representation (integer, no decimals).
     * @param tokenID is the token ID related to the conversion amount, which can be given by either it's symbol (defined in constants.ts),
     * hash (0x...) or bech32 address (zil...). The hash for ZIL is represented by the ZIL_HASH constant.
     * @param amountStr is the unitless amount as a string (e.g. 42000000000000 for 42 ZILs) to be converted.
     */
    Zilswap.prototype.toUnit = function (tokenID, amountStr) {
        var token = this.getTokenDetails(tokenID);
        var amountBN = new bignumber_js_1.BigNumber(amountStr);
        if (!amountBN.integerValue().isEqualTo(amountStr)) {
            throw new Error("Amount " + amountStr + " for " + token.symbol + " cannot have decimals.");
        }
        return amountBN.shiftedBy(-token.decimals).toString();
    };
    /**
     * Gets the expected output amount and slippage for a particular set of ZRC-2 or ZIL tokens at the given input amount.
     *
     * @param tokenInID is the token ID to be sent to Zilswap (sold), which can be given by either it's symbol (defined in constants.ts),
     * hash (0x...) or bech32 address (zil...). The hash for ZIL is represented by the ZIL_HASH constant.
     * @param tokenOutID is the token ID to be taken from Zilswap (bought), which can be given by either it's symbol (defined in constants.ts),
     * hash (0x...) or bech32 address (zil...). The hash for ZIL is represented by the ZIL_HASH constant.
     * @param tokenInAmountStr is the exact amount of tokens to be sent to Zilswap as a unitless representable string (without decimals).
     */
    Zilswap.prototype.getRatesForInput = function (tokenInID, tokenOutID, tokenInAmountStr) {
        var tokenIn = this.getTokenDetails(tokenInID);
        var tokenOut = this.getTokenDetails(tokenOutID);
        var tokenInAmount = unitlessBigNumber(tokenInAmountStr);
        var _a = this.getOutputs(tokenIn, tokenOut, tokenInAmount), epsilonOutput = _a.epsilonOutput, expectedOutput = _a.expectedOutput;
        return {
            expectedAmount: expectedOutput,
            slippage: epsilonOutput.minus(expectedOutput).times(100).dividedBy(epsilonOutput).minus(0.3),
        };
    };
    /**
     * Gets the expected input amount and slippage for a particular set of ZRC-2 or ZIL tokens at the given output amount.
     * Returns NaN values if the given output amount is larger than the pool reserve.
     *
     * @param tokenInID is the token ID to be sent to Zilswap (sold), which can be given by either it's symbol (defined in constants.ts),
     * hash (0x...) or bech32 address (zil...). The hash for ZIL is represented by the ZIL_HASH constant.
     * @param tokenOutID is the token ID to be taken from Zilswap (bought), which can be given by either it's symbol (defined in constants.ts),
     * hash (0x...) or bech32 address (zil...). The hash for ZIL is represented by the ZIL_HASH constant.
     * @param tokenOutAmountStr is the exact amount of tokens to be received from Zilswap as a unitless representable string (without decimals).
     */
    Zilswap.prototype.getRatesForOutput = function (tokenInID, tokenOutID, tokenOutAmountStr) {
        var tokenIn = this.getTokenDetails(tokenInID);
        var tokenOut = this.getTokenDetails(tokenOutID);
        var tokenOutAmount = unitlessBigNumber(tokenOutAmountStr);
        var _a = this.getInputs(tokenIn, tokenOut, tokenOutAmount), epsilonInput = _a.epsilonInput, expectedInput = _a.expectedInput;
        return {
            expectedAmount: expectedInput,
            slippage: expectedInput.minus(epsilonInput).times(100).dividedBy(expectedInput).minus(0.3),
        };
    };
    /**
     * Sets the number of blocks to use as the allowable buffer duration before transactions
     * are considered invalid.
     *
     * When a transaction is signed, the deadline block by adding the buffer blocks to
     * the latest confirmed block height.
     *
     * @param bufferBlocks is the number of blocks to use as buffer for the deadline block.
     */
    Zilswap.prototype.setDeadlineBlocks = function (bufferBlocks) {
        if (bufferBlocks <= 0) {
            throw new Error('Buffer blocks must be greater than 0.');
        }
        this.deadlineBuffer = bufferBlocks;
    };
    /**
     * Observes the given transaction until the deadline block.
     *
     * Calls the `OnUpdate` callback given during `initialize` with the updated ObservedTx
     * when a change has been observed.
     *
     * @param observedTx is the txn hash of the txn to observe with the deadline block number.
     */
    Zilswap.prototype.observeTx = function (observedTx) {
        return __awaiter(this, void 0, void 0, function () {
            var release;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.observerMutex.acquire()];
                    case 1:
                        release = _a.sent();
                        try {
                            this.observedTxs.push(observedTx);
                        }
                        finally {
                            release();
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Adds a token which is not already loaded by the default tokens file to the SDK.
     * @param tokenAddress is the token address in base16 (0x...) or bech32 (zil...) form.
     *
     * @returns true if the token could be found, or false otherwise.
     */
    Zilswap.prototype.addToken = function (tokenAddress) {
        return __awaiter(this, void 0, void 0, function () {
            var details, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.appState) {
                            throw new Error('App state not loaded, call #initialize first.');
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.fetchTokenDetails(tokenAddress)];
                    case 2:
                        details = _b.sent();
                        this.appState.tokens[details.hash] = details;
                        return [2 /*return*/, true];
                    case 3:
                        _a = _b.sent();
                        return [2 /*return*/, false];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Approves allowing the Zilswap contract to transfer ZRC-2 token with `tokenID`, if the current
     * approved allowance is less than `amount`. If the allowance is sufficient, this method is a no-op.
     *
     * The approval is done by calling `IncreaseAllowance` with the allowance amount as the entire
     * token supply. This is done so that the approval needs to only be done once per token contract,
     * reducing the number of approval transactions required for users conducting multiple swaps.
     *
     * Non-custodial control of the token is ensured by the Zilswap contract itself, which does not
     * allow for the transfer of tokens unless explicitly invoked by the sender.
     *
     * The transaction is added to the list of observedTxs, and the observer will be notified on
     * a confirmation or rejection event. The transation will be assumed to be expired after the default
     * deadline buffer, even though there is no deadline block for this transaction.
     *
     * @param tokenID is the token ID for the pool, which can be given by either it's symbol (defined in constants.ts),
     * hash (0x...) or bech32 address (zil...).
     * @param amountStrOrBN is the required allowance amount the Zilswap contract requires, below which the
     * `IncreaseAllowance` transition is invoked, as a unitless string or BigNumber.
     *
     * @returns an ObservedTx if IncreaseAllowance was called, null if not.
     */
    Zilswap.prototype.approveTokenTransferIfRequired = function (tokenID, amountStrOrBN) {
        return __awaiter(this, void 0, void 0, function () {
            var token, tokenState, allowances, userAllowances, allowance, amount, approveTxn, observeTxn, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Check logged in
                        this.checkAppLoadedWithUser();
                        token = this.getTokenDetails(tokenID);
                        return [4 /*yield*/, token.contract.getState()];
                    case 1:
                        tokenState = _a.sent();
                        allowances = tokenState.allowances || tokenState.allowances_map;
                        userAllowances = allowances[this.appState.currentUser] || {};
                        allowance = new bignumber_js_1.BigNumber(userAllowances[this.contractHash] || 0);
                        amount = typeof amountStrOrBN === 'string' ? unitlessBigNumber(amountStrOrBN) : amountStrOrBN;
                        if (!allowance.lt(amount)) return [3 /*break*/, 6];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 5, , 6]);
                        console.log('sending increase allowance txn..');
                        return [4 /*yield*/, this.callContract(token.contract, 'IncreaseAllowance', [
                                {
                                    vname: 'spender',
                                    type: 'ByStr20',
                                    value: this.contractHash,
                                },
                                {
                                    vname: 'amount',
                                    type: 'Uint128',
                                    value: new bignumber_js_1.BigNumber(2).pow(128).minus(1).minus(allowance).toString(),
                                },
                            ], __assign({ amount: new util_1.BN(0) }, this.txParams()), true)];
                    case 3:
                        approveTxn = _a.sent();
                        observeTxn = {
                            hash: approveTxn.id,
                            deadline: this.deadlineBlock(),
                        };
                        return [4 /*yield*/, this.observeTx(observeTxn)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/, observeTxn];
                    case 5:
                        err_1 = _a.sent();
                        if (err_1.message === 'Could not get balance') {
                            throw new Error('No ZIL to pay for transaction.');
                        }
                        else {
                            throw err_1;
                        }
                        return [3 /*break*/, 6];
                    case 6: return [2 /*return*/, null];
                }
            });
        });
    };
    /**
     * Adds liquidity to the pool with the given `tokenID`. The given `zilsToAddHuman` represents the exact quantity of ZIL
     * that will be contributed, while the given `tokensToAddHuman` represents the target quantity of ZRC-2 tokens to be
     * contributed.
     *
     * To ensure the liquidity contributor does not lose value to arbitrage, the target token amount should be strictly
     * derived from the current exchange rate that can be found using {@linkcode getPool}.
     *
     * The maximum fluctuation in exchange rate from the given parameters can be controlled through `maxExchangeRateChange`,
     * to protect against changes in pool reserves between the txn submission and txn confirmation on the Zilliqa blockchain.
     *
     * If the pool has no liquidity yet, the token amount given will be the exact quantity of tokens that will be contributed,
     * and the `maxExchangeRateChange` is ignored.
     *
     * The transaction is added to the list of observedTxs, and the observer will be notified on change in tx status.
     *
     * Note that all amounts should be given with decimals in it's human represented form, rather than as a unitless integer.
     *
     * @param tokenID is the token ID for the pool, which can be given by either it's symbol (defined in constants.ts),
     * hash (0x...) or bech32 address (zil...).
     * @param zilsToAddStr is the exact amount of zilliqas to contribute to the pool in ZILs as a unitless string.
     * @param tokensToAddStr is the target amount of tokens to contribute to the pool as a unitless string.
     * @param maxExchangeRateChange is the maximum allowed exchange rate flucuation
     * given in {@link https://www.investopedia.com/terms/b/basispoint.asp basis points}. Defaults to 200 = 2.00% if not provided.
     */
    Zilswap.prototype.addLiquidity = function (tokenID, zilsToAddStr, tokensToAddStr, maxExchangeRateChange) {
        if (maxExchangeRateChange === void 0) { maxExchangeRateChange = 200; }
        return __awaiter(this, void 0, void 0, function () {
            var token, zil, tokensToAdd, zilsToAdd, pool, maxTokens, minContribution, zilReserve, totalContribution, numerator, denominator, deadline, addLiquidityTxn, observeTxn;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Check logged in
                        this.checkAppLoadedWithUser();
                        token = this.getTokenDetails(tokenID);
                        zil = this.getTokenDetails(constants_1.ZIL_HASH);
                        tokensToAdd = new bignumber_js_1.BigNumber(tokensToAddStr);
                        zilsToAdd = new bignumber_js_1.BigNumber(zilsToAddStr);
                        pool = this.getPool(token.hash);
                        maxTokens = pool ? tokensToAdd.times(constants_1.BASIS + maxExchangeRateChange).dividedToIntegerBy(constants_1.BASIS) : tokensToAdd;
                        minContribution = new util_1.BN(0);
                        if (pool) {
                            zilReserve = pool.zilReserve;
                            this.validateMaxExchangeRateChange(maxExchangeRateChange);
                            totalContribution = pool.totalContribution;
                            numerator = totalContribution.times(zilsToAdd.toString());
                            denominator = new bignumber_js_1.BigNumber(constants_1.BASIS).plus(maxExchangeRateChange).sqrt().times(zilReserve.toString());
                            minContribution = new util_1.BN(numerator.dividedToIntegerBy(denominator).toString());
                        }
                        // Check balances
                        return [4 /*yield*/, this.checkAllowedBalance(token, tokensToAdd)];
                    case 1:
                        // Check balances
                        _a.sent();
                        return [4 /*yield*/, this.checkAllowedBalance(zil, zilsToAdd)];
                    case 2:
                        _a.sent();
                        deadline = this.deadlineBlock();
                        console.log('sending add liquidity txn..');
                        return [4 /*yield*/, this.callContract(this.contract, 'AddLiquidity', [
                                {
                                    vname: 'token_address',
                                    type: 'ByStr20',
                                    value: token.hash,
                                },
                                {
                                    vname: 'min_contribution_amount',
                                    type: 'Uint128',
                                    value: minContribution.toString(),
                                },
                                {
                                    vname: 'max_token_amount',
                                    type: 'Uint128',
                                    value: maxTokens.toString(),
                                },
                                {
                                    vname: 'deadline_block',
                                    type: 'BNum',
                                    value: deadline.toString(),
                                },
                            ], __assign({ amount: new util_1.BN(zilsToAdd.toString()) }, this.txParams()), true)];
                    case 3:
                        addLiquidityTxn = _a.sent();
                        if (addLiquidityTxn.isRejected()) {
                            throw new Error('Submitted transaction was rejected.');
                        }
                        observeTxn = {
                            hash: addLiquidityTxn.id,
                            deadline: deadline,
                        };
                        return [4 /*yield*/, this.observeTx(observeTxn)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/, observeTxn];
                }
            });
        });
    };
    /**
     * Removes `contributionAmount` worth of liquidity from the pool with the given `tokenID`.
     *
     * The current user's contribution can be fetched in {@linkcode getPool}, and the expected returned amounts at the
     * current prevailing exchange rates can be calculated by prorating the liquidity pool reserves by the fraction of
     * the user's current contribution against the pool's total contribution.
     *
     * The maximum fluctuation in exchange rate from the given parameters can be controlled through `maxExchangeRateChange`,
     * to protect against changes in pool reserves between the txn submission and txn confirmation on the Zilliqa blockchain.
     *
     * The transaction is added to the list of observedTxs, and the observer will be notified on change in tx status.
     *
     * @param tokenID is the token ID for the pool, which can be given by either it's symbol (defined in constants.ts),
     * hash (0x...) or bech32 address (zil...).
     * @param contributionAmount is the exact amount of zilliqas to contribute to the pool in ZILs as a string.
     * @param maxExchangeRateChange is the maximum allowed exchange rate flucuation
     * given in {@link https://www.investopedia.com/terms/b/basispoint.asp basis points}. Defaults to 200 = 2.00% if not provided.
     */
    Zilswap.prototype.removeLiquidity = function (tokenID, contributionAmount, maxExchangeRateChange) {
        if (maxExchangeRateChange === void 0) { maxExchangeRateChange = 200; }
        return __awaiter(this, void 0, void 0, function () {
            var token, pool, zilReserve, tokenReserve, userContribution, contributionPercentage, expectedZilAmount, expectedTokenAmount, minZilAmount, minTokenAmount, deadline, removeLiquidityTxn, observeTxn;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Check logged in
                        this.checkAppLoadedWithUser();
                        // Check parameters
                        this.validateMaxExchangeRateChange(maxExchangeRateChange);
                        token = this.getTokenDetails(tokenID);
                        pool = this.getPool(token.hash);
                        if (!pool) {
                            throw new Error('Pool not found.');
                        }
                        zilReserve = pool.zilReserve, tokenReserve = pool.tokenReserve, userContribution = pool.userContribution, contributionPercentage = pool.contributionPercentage;
                        expectedZilAmount = zilReserve.times(contributionPercentage).times(contributionAmount).dividedBy(userContribution.times(100));
                        expectedTokenAmount = tokenReserve.times(contributionPercentage).times(contributionAmount).dividedBy(userContribution.times(100));
                        minZilAmount = expectedZilAmount.times(constants_1.BASIS).dividedToIntegerBy(constants_1.BASIS + maxExchangeRateChange);
                        minTokenAmount = expectedTokenAmount.times(constants_1.BASIS).dividedToIntegerBy(constants_1.BASIS + maxExchangeRateChange);
                        // Check contribution
                        if (userContribution.lt(contributionAmount)) {
                            throw new Error('Trying to remove more contribution than available.');
                        }
                        deadline = this.deadlineBlock();
                        console.log('sending remove liquidity txn..');
                        return [4 /*yield*/, this.callContract(this.contract, 'RemoveLiquidity', [
                                {
                                    vname: 'token_address',
                                    type: 'ByStr20',
                                    value: token.hash,
                                },
                                {
                                    vname: 'contribution_amount',
                                    type: 'Uint128',
                                    value: contributionAmount,
                                },
                                {
                                    vname: 'min_zil_amount',
                                    type: 'Uint128',
                                    value: minZilAmount.toString(),
                                },
                                {
                                    vname: 'min_token_amount',
                                    type: 'Uint128',
                                    value: minTokenAmount.toString(),
                                },
                                {
                                    vname: 'deadline_block',
                                    type: 'BNum',
                                    value: deadline.toString(),
                                },
                            ], __assign({ amount: new util_1.BN(0) }, this.txParams()), true)];
                    case 1:
                        removeLiquidityTxn = _a.sent();
                        if (removeLiquidityTxn.isRejected()) {
                            throw new Error('Submitted transaction was rejected.');
                        }
                        observeTxn = {
                            hash: removeLiquidityTxn.id,
                            deadline: deadline,
                        };
                        return [4 /*yield*/, this.observeTx(observeTxn)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, observeTxn];
                }
            });
        });
    };
    /**
     * Swaps ZIL or a ZRC-2 token with `tokenInID` for a corresponding ZIL or ZRC-2 token with `tokenOutID`.
     *
     * The exact amount of ZIL or ZRC-2 to be sent in (sold) is `tokenInAmountHuman`. The amount received is determined by the prevailing
     * exchange rate at the current AppState. The expected amount to be received can be given fetched by getExpectedOutput (NYI).
     *
     * The maximum additional slippage incurred due to fluctuations in exchange rate from when the
     * transaction is signed and when it is processed by the Zilliqa blockchain can be bounded by the
     * `maxAdditionalSlippage` variable.
     *
     * The transaction is added to the list of observedTxs, and the observer will be notified on change in tx status.
     *
     * @param tokenInID is the token ID to be sent to Zilswap (sold), which can be given by either it's symbol (defined in constants.ts),
     * hash (0x...) or bech32 address (zil...). The hash for ZIL is represented by the ZIL_HASH constant.
     * @param tokenOutID is the token ID to be taken from Zilswap (bought), which can be given by either it's symbol (defined in constants.ts),
     * hash (0x...) or bech32 address (zil...). The hash for ZIL is represented by the ZIL_HASH constant.
     * @param tokenInAmountStr is the exact amount of tokens to be sent to Zilswap as a unitless string (without decimals).
     * @param maxAdditionalSlippage is the maximum additional slippage (on top of slippage due to constant product formula) that the
     * transition will allow before reverting.
     * @param recipientAddress is an optional recipient address for receiving the output of the swap in base16 (0x...) or bech32 (zil...).
     * Defaults to the sender address if `null` or undefined.
     */
    Zilswap.prototype.swapWithExactInput = function (tokenInID, tokenOutID, tokenInAmountStr, maxAdditionalSlippage, recipientAddress) {
        if (maxAdditionalSlippage === void 0) { maxAdditionalSlippage = 200; }
        if (recipientAddress === void 0) { recipientAddress = null; }
        return __awaiter(this, void 0, void 0, function () {
            var tokenIn, tokenOut, tokenInAmount, expectedOutput, minimumOutput, parsedRecipientAddress, deadline, txn, swapTxn, observeTxn;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.checkAppLoadedWithUser();
                        tokenIn = this.getTokenDetails(tokenInID);
                        tokenOut = this.getTokenDetails(tokenOutID);
                        tokenInAmount = unitlessBigNumber(tokenInAmountStr);
                        expectedOutput = this.getOutputs(tokenIn, tokenOut, tokenInAmount).expectedOutput;
                        minimumOutput = expectedOutput.times(constants_1.BASIS).dividedToIntegerBy(constants_1.BASIS + maxAdditionalSlippage);
                        parsedRecipientAddress = this.parseRecipientAddress(recipientAddress);
                        return [4 /*yield*/, this.checkAllowedBalance(tokenIn, tokenInAmount)];
                    case 1:
                        _a.sent();
                        deadline = this.deadlineBlock();
                        if (tokenIn.hash === constants_1.ZIL_HASH) {
                            // zil to zrc2
                            txn = {
                                transition: 'SwapExactZILForTokens',
                                args: [
                                    {
                                        vname: 'token_address',
                                        type: 'ByStr20',
                                        value: tokenOut.hash,
                                    },
                                    {
                                        vname: 'min_token_amount',
                                        type: 'Uint128',
                                        value: minimumOutput.toString(),
                                    },
                                    {
                                        vname: 'deadline_block',
                                        type: 'BNum',
                                        value: deadline.toString(),
                                    },
                                    {
                                        vname: 'recipient_address',
                                        type: 'ByStr20',
                                        value: parsedRecipientAddress,
                                    },
                                ],
                                params: __assign({ amount: new util_1.BN(tokenInAmount.toString()) }, this.txParams()),
                            };
                        }
                        else if (tokenOut.hash === constants_1.ZIL_HASH) {
                            // zrc2 to zil
                            txn = {
                                transition: 'SwapExactTokensForZIL',
                                args: [
                                    {
                                        vname: 'token_address',
                                        type: 'ByStr20',
                                        value: tokenIn.hash,
                                    },
                                    {
                                        vname: 'token_amount',
                                        type: 'Uint128',
                                        value: tokenInAmount.toString(),
                                    },
                                    {
                                        vname: 'min_zil_amount',
                                        type: 'Uint128',
                                        value: minimumOutput.toString(),
                                    },
                                    {
                                        vname: 'deadline_block',
                                        type: 'BNum',
                                        value: deadline.toString(),
                                    },
                                    {
                                        vname: 'recipient_address',
                                        type: 'ByStr20',
                                        value: parsedRecipientAddress,
                                    },
                                ],
                                params: __assign({ amount: new util_1.BN(0) }, this.txParams()),
                            };
                        }
                        else {
                            // zrc2 to zrc2
                            txn = {
                                transition: 'SwapExactTokensForTokens',
                                args: [
                                    {
                                        vname: 'token0_address',
                                        type: 'ByStr20',
                                        value: tokenIn.hash,
                                    },
                                    {
                                        vname: 'token1_address',
                                        type: 'ByStr20',
                                        value: tokenOut.hash,
                                    },
                                    {
                                        vname: 'token0_amount',
                                        type: 'Uint128',
                                        value: tokenInAmount.toString(),
                                    },
                                    {
                                        vname: 'min_token1_amount',
                                        type: 'Uint128',
                                        value: minimumOutput.toString(),
                                    },
                                    {
                                        vname: 'deadline_block',
                                        type: 'BNum',
                                        value: deadline.toString(),
                                    },
                                    {
                                        vname: 'recipient_address',
                                        type: 'ByStr20',
                                        value: parsedRecipientAddress,
                                    },
                                ],
                                params: __assign({ amount: new util_1.BN(0) }, this.txParams()),
                            };
                        }
                        console.log('sending swap txn..');
                        return [4 /*yield*/, this.callContract(this.contract, txn.transition, txn.args, txn.params, true)];
                    case 2:
                        swapTxn = _a.sent();
                        if (swapTxn.isRejected()) {
                            throw new Error('Submitted transaction was rejected.');
                        }
                        observeTxn = {
                            hash: swapTxn.id,
                            deadline: deadline,
                        };
                        return [4 /*yield*/, this.observeTx(observeTxn)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, observeTxn];
                }
            });
        });
    };
    /**
     * Swaps ZIL or a ZRC-2 token with `tokenInID` for a corresponding ZIL or ZRC-2 token with `tokenOutID`.
     *
     * The exact amount of ZIL or ZRC-2 to be received (bought) is `tokenOutAmountHuman`. The amount sent is determined by the prevailing
     * exchange rate at the current AppState. The expected amount to be sent can be given fetched by getExpectedInput (NYI).
     *
     * The maximum additional slippage incurred due to fluctuations in exchange rate from when the
     * transaction is signed and when it is processed by the Zilliqa blockchain can be bounded by the
     * `maxAdditionalSlippage` variable.
     *
     * The transaction is added to the list of observedTxs, and the observer will be notified on change in tx status.
     *
     * @param tokenInID is the token ID to be sent to Zilswap (sold), which can be given by either it's symbol (defined in constants.ts),
     * hash (0x...) or bech32 address (zil...). The hash for ZIL is represented by the ZIL_HASH constant.
     * @param tokenOutID is the token ID to be taken from Zilswap (bought), which can be given by either it's symbol (defined in constants.ts),
     * hash (0x...) or bech32 address (zil...). The hash for ZIL is represented by the ZIL_HASH constant.
     * @param tokenOutAmountStr is the exact amount of tokens to be received from Zilswap as a unitless string (withoout decimals).
     * @param maxAdditionalSlippage is the maximum additional slippage (on top of slippage due to constant product formula) that the
     * transition will allow before reverting.
     * @param recipientAddress is an optional recipient address for receiving the output of the swap in base16 (0x...) or bech32 (zil...).
     * Defaults to the sender address if `null` or undefined.
     */
    Zilswap.prototype.swapWithExactOutput = function (tokenInID, tokenOutID, tokenOutAmountStr, maxAdditionalSlippage, recipientAddress) {
        if (maxAdditionalSlippage === void 0) { maxAdditionalSlippage = 200; }
        if (recipientAddress === void 0) { recipientAddress = null; }
        return __awaiter(this, void 0, void 0, function () {
            var tokenIn, tokenOut, tokenOutAmount, expectedInput, maximumInput, parsedRecipientAddress, deadline, txn, swapTxn, observeTxn;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.checkAppLoadedWithUser();
                        tokenIn = this.getTokenDetails(tokenInID);
                        tokenOut = this.getTokenDetails(tokenOutID);
                        tokenOutAmount = unitlessBigNumber(tokenOutAmountStr);
                        expectedInput = this.getInputs(tokenIn, tokenOut, tokenOutAmount).expectedInput;
                        maximumInput = expectedInput.times(constants_1.BASIS + maxAdditionalSlippage).dividedToIntegerBy(constants_1.BASIS);
                        parsedRecipientAddress = this.parseRecipientAddress(recipientAddress);
                        return [4 /*yield*/, this.checkAllowedBalance(tokenIn, maximumInput)];
                    case 1:
                        _a.sent();
                        deadline = this.deadlineBlock();
                        if (tokenIn.hash === constants_1.ZIL_HASH) {
                            // zil to zrc2
                            txn = {
                                transition: 'SwapZILForExactTokens',
                                args: [
                                    {
                                        vname: 'token_address',
                                        type: 'ByStr20',
                                        value: tokenOut.hash,
                                    },
                                    {
                                        vname: 'token_amount',
                                        type: 'Uint128',
                                        value: tokenOutAmount.toString(),
                                    },
                                    {
                                        vname: 'deadline_block',
                                        type: 'BNum',
                                        value: deadline.toString(),
                                    },
                                    {
                                        vname: 'recipient_address',
                                        type: 'ByStr20',
                                        value: parsedRecipientAddress,
                                    },
                                ],
                                params: __assign({ amount: new util_1.BN(maximumInput.toString()) }, this.txParams()),
                            };
                        }
                        else if (tokenOut.hash === constants_1.ZIL_HASH) {
                            // zrc2 to zil
                            txn = {
                                transition: 'SwapTokensForExactZIL',
                                args: [
                                    {
                                        vname: 'token_address',
                                        type: 'ByStr20',
                                        value: tokenIn.hash,
                                    },
                                    {
                                        vname: 'max_token_amount',
                                        type: 'Uint128',
                                        value: maximumInput.toString(),
                                    },
                                    {
                                        vname: 'zil_amount',
                                        type: 'Uint128',
                                        value: tokenOutAmount.toString(),
                                    },
                                    {
                                        vname: 'deadline_block',
                                        type: 'BNum',
                                        value: deadline.toString(),
                                    },
                                    {
                                        vname: 'recipient_address',
                                        type: 'ByStr20',
                                        value: parsedRecipientAddress,
                                    },
                                ],
                                params: __assign({ amount: new util_1.BN(0) }, this.txParams()),
                            };
                        }
                        else {
                            // zrc2 to zrc2
                            txn = {
                                transition: 'SwapTokensForExactTokens',
                                args: [
                                    {
                                        vname: 'token0_address',
                                        type: 'ByStr20',
                                        value: tokenIn.hash,
                                    },
                                    {
                                        vname: 'token1_address',
                                        type: 'ByStr20',
                                        value: tokenOut.hash,
                                    },
                                    {
                                        vname: 'max_token0_amount',
                                        type: 'Uint128',
                                        value: maximumInput.toString(),
                                    },
                                    {
                                        vname: 'token1_amount',
                                        type: 'Uint128',
                                        value: tokenOutAmount.toString(),
                                    },
                                    {
                                        vname: 'deadline_block',
                                        type: 'BNum',
                                        value: deadline.toString(),
                                    },
                                    {
                                        vname: 'recipient_address',
                                        type: 'ByStr20',
                                        value: parsedRecipientAddress,
                                    },
                                ],
                                params: __assign({ amount: new util_1.BN(0) }, this.txParams()),
                            };
                        }
                        console.log('sending swap txn..');
                        return [4 /*yield*/, this.callContract(this.contract, txn.transition, txn.args, txn.params, true)];
                    case 2:
                        swapTxn = _a.sent();
                        if (swapTxn.isRejected()) {
                            throw new Error('Submitted transaction was rejected.');
                        }
                        observeTxn = {
                            hash: swapTxn.id,
                            deadline: deadline,
                        };
                        return [4 /*yield*/, this.observeTx(observeTxn)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, observeTxn];
                }
            });
        });
    };
    Zilswap.prototype.getInputs = function (tokenIn, tokenOut, tokenOutAmount) {
        var expectedInput; // the expected amount after slippage and fees
        var epsilonInput; // the zero slippage input
        if (tokenIn.hash === constants_1.ZIL_HASH) {
            // zil to zrc2
            var _a = this.getReserves(tokenOut), zilReserve = _a.zilReserve, tokenReserve = _a.tokenReserve;
            epsilonInput = tokenOutAmount.times(zilReserve).dividedToIntegerBy(tokenReserve);
            expectedInput = this.getInputFor(tokenOutAmount, zilReserve, tokenReserve);
        }
        else if (tokenOut.hash === constants_1.ZIL_HASH) {
            // zrc2 to zil
            var _b = this.getReserves(tokenIn), zilReserve = _b.zilReserve, tokenReserve = _b.tokenReserve;
            epsilonInput = tokenOutAmount.times(tokenReserve).dividedToIntegerBy(zilReserve);
            expectedInput = this.getInputFor(tokenOutAmount, tokenReserve, zilReserve);
        }
        else {
            // zrc2 to zrc2
            var _c = this.getReserves(tokenOut), zr1 = _c.zilReserve, tr1 = _c.tokenReserve;
            var intermediateEpsilonInput = tokenOutAmount.times(zr1).dividedToIntegerBy(tr1);
            var intermediateInput = this.getInputFor(tokenOutAmount, zr1, tr1);
            var _d = this.getReserves(tokenIn), zr2 = _d.zilReserve, tr2 = _d.tokenReserve;
            epsilonInput = intermediateEpsilonInput.times(tr2).dividedToIntegerBy(zr2);
            expectedInput = this.getInputFor(intermediateInput, tr2, zr2);
        }
        return { epsilonInput: epsilonInput, expectedInput: expectedInput };
    };
    Zilswap.prototype.getOutputs = function (tokenIn, tokenOut, tokenInAmount) {
        var epsilonOutput; // the zero slippage output
        var expectedOutput; // the expected amount after slippage and fees
        if (tokenIn.hash === constants_1.ZIL_HASH) {
            // zil to zrc2
            var _a = this.getReserves(tokenOut), zilReserve = _a.zilReserve, tokenReserve = _a.tokenReserve;
            epsilonOutput = tokenInAmount.times(tokenReserve).dividedToIntegerBy(zilReserve);
            expectedOutput = this.getOutputFor(tokenInAmount, zilReserve, tokenReserve);
        }
        else if (tokenOut.hash === constants_1.ZIL_HASH) {
            // zrc2 to zil
            var _b = this.getReserves(tokenIn), zilReserve = _b.zilReserve, tokenReserve = _b.tokenReserve;
            epsilonOutput = tokenInAmount.times(zilReserve).dividedToIntegerBy(tokenReserve);
            expectedOutput = this.getOutputFor(tokenInAmount, tokenReserve, zilReserve);
        }
        else {
            // zrc2 to zrc2
            var _c = this.getReserves(tokenIn), zr1 = _c.zilReserve, tr1 = _c.tokenReserve;
            var intermediateEpsilonOutput = tokenInAmount.times(zr1).dividedToIntegerBy(tr1);
            var intermediateOutput = this.getOutputFor(tokenInAmount, tr1, zr1);
            var _d = this.getReserves(tokenOut), zr2 = _d.zilReserve, tr2 = _d.tokenReserve;
            epsilonOutput = intermediateEpsilonOutput.times(tr2).dividedToIntegerBy(zr2);
            expectedOutput = this.getOutputFor(intermediateOutput, zr2, tr2);
        }
        return { epsilonOutput: epsilonOutput, expectedOutput: expectedOutput };
    };
    Zilswap.prototype.getInputFor = function (outputAmount, inputReserve, outputReserve) {
        if (inputReserve.isZero() || outputReserve.isZero()) {
            throw new Error('Reserve has 0 tokens.');
        }
        if (outputReserve.lte(outputAmount)) {
            return new bignumber_js_1.BigNumber('NaN');
        }
        var numerator = inputReserve.times(outputAmount).times(10000);
        var denominator = outputReserve.minus(outputAmount).times(this.getAfterFeeBps());
        return numerator.dividedToIntegerBy(denominator).plus(1);
    };
    Zilswap.prototype.getOutputFor = function (inputAmount, inputReserve, outputReserve) {
        if (inputReserve.isZero() || outputReserve.isZero()) {
            throw new Error('Reserve has 0 tokens.');
        }
        var inputAfterFee = inputAmount.times(this.getAfterFeeBps());
        var numerator = inputAfterFee.times(outputReserve);
        var denominator = inputReserve.times(10000).plus(inputAfterFee);
        return numerator.dividedToIntegerBy(denominator);
    };
    Zilswap.prototype.getAfterFeeBps = function () {
        return this.getAppState().contractState.output_after_fee;
    };
    Zilswap.prototype.getReserves = function (token) {
        var pool = this.getPool(token.hash);
        if (!pool) {
            return {
                zilReserve: new bignumber_js_1.BigNumber(0),
                tokenReserve: new bignumber_js_1.BigNumber(0),
            };
        }
        var zilReserve = pool.zilReserve, tokenReserve = pool.tokenReserve;
        return { zilReserve: zilReserve, tokenReserve: tokenReserve };
    };
    Zilswap.prototype.callContract = function (contract, transition, args, params, toDs) {
        return __awaiter(this, void 0, void 0, function () {
            var txn;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.walletProvider) return [3 /*break*/, 2];
                        return [4 /*yield*/, contract.call(transition, args, params, toDs)];
                    case 1:
                        txn = _a.sent();
                        txn.id = txn.ID;
                        txn.isRejected = function () {
                            return this.errors.length > 0 || this.exceptions.length > 0;
                        };
                        return [2 /*return*/, txn];
                    case 2: return [4 /*yield*/, contract.callWithoutConfirm(transition, args, params, toDs)];
                    case 3: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Zilswap.prototype.subscribeToAppChanges = function () {
        var _this = this;
        var subscription = this.zilliqa.subscriptionBuilder.buildEventLogSubscriptions(constants_1.WSS[this.network], {
            addresses: [this.contractHash],
        });
        subscription.subscribe({ query: subscriptions_1.MessageType.NEW_BLOCK });
        subscription.emitter.on(subscriptions_1.StatusType.SUBSCRIBE_EVENT_LOG, function (event) {
            console.log('ws connected: ', event);
        });
        subscription.emitter.on(subscriptions_1.MessageType.NEW_BLOCK, function (event) {
            // console.log('ws new block: ', JSON.stringify(event, null, 2))
            _this.updateBlockHeight().then(function () { return _this.updateObservedTxs(); });
        });
        subscription.emitter.on(subscriptions_1.MessageType.EVENT_LOG, function (event) {
            if (!event.value)
                return;
            // console.log('ws update: ', JSON.stringify(event, null, 2))
            _this.updateAppState();
        });
        subscription.emitter.on(subscriptions_1.MessageType.UNSUBSCRIBE, function (event) {
            console.log('ws disconnected: ', event);
            _this.subscription = null;
        });
        subscription.start();
        this.subscription = subscription;
    };
    Zilswap.prototype.loadTokenList = function () {
        return __awaiter(this, void 0, void 0, function () {
            var res, tokens;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fetch('https://raw.githubusercontent.com/Switcheo/zilswap-token-list/master/tokens.json')];
                    case 1:
                        res = _a.sent();
                        return [4 /*yield*/, res.json()];
                    case 2:
                        tokens = _a.sent();
                        Object.keys(tokens[this.network]).forEach(function (key) { return (_this.tokens[key] = tokens[_this.network][key]); });
                        return [2 /*return*/];
                }
            });
        });
    };
    Zilswap.prototype.updateBlockHeight = function () {
        return __awaiter(this, void 0, void 0, function () {
            var response, bNum;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.zilliqa.blockchain.getNumTxBlocks()];
                    case 1:
                        response = _a.sent();
                        bNum = parseInt(response.result, 10);
                        this.currentBlock = bNum;
                        return [2 /*return*/];
                }
            });
        });
    };
    Zilswap.prototype.updateAppState = function () {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function () {
            var contractState, currentUser, poolTokenHashes, defaultTokenHashes, tokenHashes, tokens, promises, pools;
            var _this = this;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0: return [4 /*yield*/, this.contract.getState()];
                    case 1:
                        contractState = (_e.sent());
                        currentUser = this.walletProvider
                            ? // ugly hack for zilpay provider
                                this.walletProvider.wallet.defaultAccount.base16.toLowerCase()
                            : ((_b = (_a = this.zilliqa.wallet.defaultAccount) === null || _a === void 0 ? void 0 : _a.address) === null || _b === void 0 ? void 0 : _b.toLowerCase()) || null;
                        poolTokenHashes = Object.keys(contractState.pools);
                        defaultTokenHashes = Object.values(this.tokens).map(function (bech32) { return _this.getTokenAddresses(bech32).hash; });
                        tokenHashes = poolTokenHashes.concat(defaultTokenHashes.filter(function (item) { return poolTokenHashes.indexOf(item) < 0; }));
                        tokens = {};
                        promises = tokenHashes.map(function (hash) { return __awaiter(_this, void 0, void 0, function () {
                            var d;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this.fetchTokenDetails(hash)];
                                    case 1:
                                        d = _a.sent();
                                        tokens[hash] = d;
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                        return [4 /*yield*/, Promise.all(promises)
                            // Get exchange rates
                        ];
                    case 2:
                        _e.sent();
                        pools = {};
                        tokenHashes.forEach(function (tokenHash) {
                            if (!contractState.pools[tokenHash])
                                return;
                            var _a = contractState.pools[tokenHash].arguments, x = _a[0], y = _a[1];
                            var zilReserve = new bignumber_js_1.BigNumber(x);
                            var tokenReserve = new bignumber_js_1.BigNumber(y);
                            var exchangeRate = zilReserve.dividedBy(tokenReserve);
                            var totalContribution = new bignumber_js_1.BigNumber(contractState.total_contributions[tokenHash]);
                            var poolBalances = contractState.balances[tokenHash];
                            var userContribution = new bignumber_js_1.BigNumber(poolBalances && currentUser ? poolBalances[currentUser] || 0 : 0);
                            var contributionPercentage = userContribution.dividedBy(totalContribution).times(100);
                            pools[tokenHash] = {
                                zilReserve: zilReserve,
                                tokenReserve: tokenReserve,
                                exchangeRate: exchangeRate,
                                totalContribution: totalContribution,
                                userContribution: userContribution,
                                contributionPercentage: contributionPercentage,
                            };
                        });
                        // Set new state
                        this.appState = {
                            contractState: contractState,
                            tokens: tokens,
                            pools: pools,
                            currentUser: currentUser,
                            currentNonce: ((_c = this.appState) === null || _c === void 0 ? void 0 : _c.currentNonce) || null,
                            currentBalance: ((_d = this.appState) === null || _d === void 0 ? void 0 : _d.currentBalance) || null,
                        };
                        return [2 /*return*/];
                }
            });
        });
    };
    Zilswap.prototype.updateBalanceAndNonce = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var res, err_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!((_a = this.appState) === null || _a === void 0 ? void 0 : _a.currentUser)) return [3 /*break*/, 4];
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.zilliqa.blockchain.getBalance(this.appState.currentUser)];
                    case 2:
                        res = (_b.sent()).result;
                        if (!res) {
                            this.appState.currentBalance = new bignumber_js_1.BigNumber(0);
                            this.appState.currentNonce = 0;
                            return [2 /*return*/];
                        }
                        this.appState.currentBalance = new bignumber_js_1.BigNumber(res.balance);
                        this.appState.currentNonce = parseInt(res.nonce, 10);
                        return [3 /*break*/, 4];
                    case 3:
                        err_2 = _b.sent();
                        // ugly hack for zilpay non-standard API
                        if (err_2.message === 'Account is not created') {
                            this.appState.currentBalance = new bignumber_js_1.BigNumber(0);
                            this.appState.currentNonce = 0;
                        }
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    Zilswap.prototype.updateObservedTxs = function () {
        return __awaiter(this, void 0, void 0, function () {
            var release, removeTxs_1, promises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.observerMutex.acquire()];
                    case 1:
                        release = _a.sent();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, , 5, 6]);
                        removeTxs_1 = [];
                        promises = this.observedTxs.map(function (observedTx) { return __awaiter(_this, void 0, void 0, function () {
                            var result, confirmedTxn, receipt, txStatus;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this.zilliqa.blockchain.getPendingTxn(observedTx.hash)];
                                    case 1:
                                        result = _a.sent();
                                        if (!(result && result.confirmed)) return [3 /*break*/, 3];
                                        return [4 /*yield*/, this.zilliqa.blockchain.getTransaction(observedTx.hash)];
                                    case 2:
                                        confirmedTxn = _a.sent();
                                        receipt = confirmedTxn.getReceipt();
                                        txStatus = confirmedTxn.isRejected() ? 'rejected' : (receipt === null || receipt === void 0 ? void 0 : receipt.success) ? 'confirmed' : 'rejected';
                                        if (this.observer)
                                            this.observer(observedTx, txStatus, receipt);
                                        removeTxs_1.push(observedTx.hash);
                                        return [2 /*return*/];
                                    case 3:
                                        if (observedTx.deadline < this.currentBlock) {
                                            // expired
                                            console.log("tx deadline, current: " + observedTx.deadline + ", " + this.currentBlock);
                                            if (this.observer)
                                                this.observer(observedTx, 'expired');
                                            removeTxs_1.push(observedTx.hash);
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                        return [4 /*yield*/, Promise.all(promises)];
                    case 3:
                        _a.sent();
                        this.observedTxs = this.observedTxs.filter(function (tx) { return !removeTxs_1.includes(tx.hash); });
                        return [4 /*yield*/, this.updateBalanceAndNonce()];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        release();
                        return [7 /*endfinally*/];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    Zilswap.prototype.parseRecipientAddress = function (addr) {
        var address = addr === null ? this.getAppState().currentUser : addr;
        if (address.substr(0, 2) === '0x') {
            return address.toLowerCase();
        }
        else if (address.length === 32) {
            return ("0x" + address).toLowerCase();
        }
        else if (address.substr(0, 3) === 'zil') {
            return crypto_1.fromBech32Address(address).toLowerCase();
        }
        else {
            throw new Error('Invalid recipient address format!');
        }
    };
    Zilswap.prototype.getTokenAddresses = function (id) {
        var hash, address;
        if (id.substr(0, 2) === '0x') {
            hash = id.toLowerCase();
            address = crypto_1.toBech32Address(hash);
        }
        else if (id.substr(0, 3) === 'zil' && id.length > 3) {
            address = id;
            hash = crypto_1.fromBech32Address(address).toLowerCase();
        }
        else {
            address = this.tokens[id.toUpperCase()];
            hash = crypto_1.fromBech32Address(address).toLowerCase();
        }
        return { hash: hash, address: address };
    };
    Zilswap.prototype.getTokenDetails = function (id) {
        var hash = this.getTokenAddresses(id).hash;
        if (!this.appState) {
            throw new Error('App state not loaded, call #initialize first.');
        }
        if (!this.appState.tokens[hash]) {
            throw new Error("Could not find token details for " + id);
        }
        return this.appState.tokens[hash];
    };
    Zilswap.prototype.fetchTokenDetails = function (id) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var _b, hash, address, contract, init, decimalStr, decimals, symbol, whitelisted;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = this.getTokenAddresses(id), hash = _b.hash, address = _b.address;
                        if (!!((_a = this.appState) === null || _a === void 0 ? void 0 : _a.tokens[hash]))
                            return [2 /*return*/, this.appState.tokens[hash]];
                        contract = (this.walletProvider || this.zilliqa).contracts.at(address);
                        if (hash === constants_1.ZIL_HASH) {
                            return [2 /*return*/, { contract: contract, address: address, hash: hash, symbol: 'ZIL', decimals: 12, whitelisted: true }];
                        }
                        return [4 /*yield*/, contract.getInit()];
                    case 1:
                        init = _c.sent();
                        decimalStr = init.find(function (e) { return e.vname === 'decimals'; }).value;
                        decimals = parseInt(decimalStr, 10);
                        symbol = init.find(function (e) { return e.vname === 'symbol'; }).value;
                        whitelisted = this.tokens[symbol] === address;
                        return [2 /*return*/, { contract: contract, address: address, hash: hash, symbol: symbol, decimals: decimals, whitelisted: whitelisted }];
                }
            });
        });
    };
    Zilswap.prototype.checkAllowedBalance = function (token, amount) {
        return __awaiter(this, void 0, void 0, function () {
            var user, zilBalance, tokenState, balances, tokenBalance, allowances, userAllowances, allowance;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Check init
                        this.checkAppLoadedWithUser();
                        user = this.appState.currentUser;
                        if (!(token.hash === constants_1.ZIL_HASH)) return [3 /*break*/, 1];
                        zilBalance = this.appState.currentBalance;
                        if (zilBalance.lt(amount)) {
                            throw new Error("Insufficent ZIL in wallet.\n        Required: " + this.toUnit(token.hash, amount.toString()).toString() + ",\n        have: " + this.toUnit(token.hash, zilBalance.toString()).toString() + ".");
                        }
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, token.contract.getState()];
                    case 2:
                        tokenState = _a.sent();
                        balances = tokenState.balances || tokenState.balances_map;
                        tokenBalance = new bignumber_js_1.BigNumber(balances[user] || 0);
                        if (tokenBalance.lt(amount)) {
                            throw new Error("Insufficent tokens in wallet.\n        Required: " + this.toUnit(token.hash, amount.toString()).toString() + ",\n        have: " + this.toUnit(token.hash, tokenBalance.toString()).toString() + ".");
                        }
                        allowances = tokenState.allowances || tokenState.allowances_map;
                        userAllowances = allowances[user] || {};
                        allowance = new bignumber_js_1.BigNumber(userAllowances[this.contractHash] || 0);
                        if (allowance.lt(amount)) {
                            throw new Error("Tokens need to be approved first.\n        Required: " + this.toUnit(token.hash, amount.toString()).toString() + ",\n        approved: " + this.toUnit(token.hash, allowance.toString()).toString() + ".");
                        }
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    Zilswap.prototype.checkAppLoadedWithUser = function () {
        // Check init
        if (!this.appState) {
            throw new Error('App state not loaded, call #initialize first.');
        }
        // Check user address
        if (this.appState.currentUser === null) {
            throw new Error('No wallet connected.');
        }
        // Check wallet account
        if (this.walletProvider && this.walletProvider.wallet.defaultAccount.base16.toLowerCase() !== this.appState.currentUser) {
            throw new Error('Wallet user has changed, please reconnect.');
        }
        // Check network is correct
        if (this.walletProvider && this.walletProvider.wallet.net.toLowerCase() !== this.network.toLowerCase()) {
            throw new Error('Wallet is connected to wrong network.');
        }
    };
    Zilswap.prototype.txParams = function () {
        return __assign({ nonce: this.nonce() }, this._txParams);
    };
    Zilswap.prototype.deadlineBlock = function () {
        return this.currentBlock + this.deadlineBuffer;
    };
    Zilswap.prototype.nonce = function () {
        return this.appState.currentNonce + this.observedTxs.length + 1;
    };
    Zilswap.prototype.validateMaxExchangeRateChange = function (maxExchangeRateChange) {
        if (maxExchangeRateChange % 1 !== 0 || maxExchangeRateChange >= constants_1.BASIS || maxExchangeRateChange < 0) {
            throw new Error("MaxExchangeRateChange " + maxExchangeRateChange + " must be an integer between 0 and " + (constants_1.BASIS + 1) + ".");
        }
    };
    return Zilswap;
}());
exports.Zilswap = Zilswap;
var unitlessBigNumber = function (str) {
    var bn = new bignumber_js_1.BigNumber(str);
    if (!bn.integerValue().isEqualTo(bn)) {
        throw new Error("number " + bn + " should be unitless (no decimals).");
    }
    return bn;
};
//# sourceMappingURL=index.js.map